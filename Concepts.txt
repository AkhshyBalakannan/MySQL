MySQL

InnoDB is a general-purpose storage engine that balances high reliability and high performance. 
In MySQL 5.6, InnoDB is the default MySQL storage engine. Unless you have configured a different 
default storage engine, issuing a CREATE TABLE statement without an ENGINE clause creates an InnoDB table.


Type of programming we do in MySQL is Declarative and nonprocedural
	Which means what is needed and not carry about how to 

Here everything is table where the data are stored in a table
	Stored tabular

Each value are data value
Each row are called as Record
Each column are called as Field

Entity = the smallest unit that can contain a meaningful set of data

Entity = Database Object

Horizontal Entity	ROW		entity instance

Vertical Entity		COLUMN

Main Components of SQL's syntax:

Data Definition Language (DDL)		creation of data
Data Manipulation Language (DML)	manipulation of data	
Data Control Language (DCL)		assignment and removal of permission to use this data
Transaction Control Language (TCL)	saving and restoring changes to a database

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

Data Definition Language (DDL):

	SQL Syntax
	comprises several types of statement that allow you to perform various commands and op

	a syntax
	a set of statements that allow the user to define or modify data structure and objects
	such as tables

DDL - CREATE, ALTER, DROP, RENAME, TRUNCATE.

	the CREATE statement
	used for creating entire databses and database object as tables

CREATE object_type object_name;
CREATE TABLE object_name (column_name data_type)
CREATE TABLE sales (purchase_number INT);
------------------------------------------------------------------------------
	
	the ALTER statement
	used when altering existing objects
	- ADD
	- REMOVE
	- RENAME

ALTER TABLE sales
ADD COLUMN date_of_purchase DATE;
------------------------------------------------------------------------------
	
	the DROP statement
	used when deleting the entire table

DROP TABLE customer;
------------------------------------------------------------------------------

	the RENAME statement
	allows us to rename an object

RENAME object_type object_name TO new_object_name;
------------------------------------------------------------------------------

	the TRUNCATE statement
	instead of deleting an entire table through DROP,
	we can also remove its data and continue to have the table as an object in db

TRUNCATE object_type object_name
TRUNCATE TABLE customers;  
------------------------------------------------------------------------------

SQL keywords = reserved words

	ADD CREATE ALTER etc 	
Keywords in SQL cannot be variable names
	objects or databases cannot have names that coincide with SQL keywords
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

Data Manipulation Language (DML)
	its statements allow us to manipulate the data in the tables of a database

DML - 
	SELECT... FROM...
	INSERT INTO... VALUES
	UPDATE... SET... WHERE
	DELETE... FROM... WHERE


	the SELECT statement
	used to retrieve data from database objects, like tables

SELECT * FROM sales;
SELECT ... FROM sales;
------------------------------------------------------------------------------

	the INSERT statement
	used to insert data into tables

INSERT ... INTO ... VALUES ...;
INSERT INTO sales(purchase_number, date_of_purchase) VALUES (1, '2021-07-22');
INSERT INTO sales VALUES (1, '2021-07-22');
INSERT INTO sales VALUES (2, '2021-07-22');
-------------------------------------------------------------------------------

	the UPDATE statement
	allows you to renew existing data of your tables
	this is based on the WHERE statement

UPDATE sales
SET date_of_purchase = '2021-07-21'
WHERE purchase_number = 1;
--------------------------------------------------------------------------------

	the DELETE statement
	functions similarly to the TRUNCATE statement
	
	TRUNCATE vs. DELETE
	TRUNCATE allows us to remove all the record contained in a table
	Truncation operations cannot be performed if the session holds an active table lock.
				vs
	with DELETE, you can specify precisely what you would like to be removed

DELETE FROM sales;	==	TRUNCATE TABLE sales;
	which will delete all the data in table

DELETE FROM sales
WHERE purchase_number = 1;
	which will delete only one record which is with purchase_number = 1

----------------------------------------------------------------------------
----------------------------------------------------------------------------

Data Control Language (DCL)

	the GRANT and REVOKE statements
	allow us to manage the rights user have in a database


	the GRANT statement
	gives (or grants) certain permissions to users

	one can grant a specific type of permission, like complete or partial access

GRANT type_of_permission ON database_name.table_name TO
'username'@'loaclhost'
	these rights will be assigned to a person who has a username registered at local server

	Big companies and corporation don't use this type of server, and their databases 
	lay on external, more powerful servers
-------------------------------------------------------------------------------------------------

	To Create an user in the MySQL we give
	
CREATE USER 'frank'@'localhost' IDENTIFIED BY 'pass';
	this line will create an user frank with the password of pass who can access data

GRANT SELECT ON sales.customers to 'frank'@'localhost';

	The above line will allow frank to select data from the table BUT
	 will not allow him to perform any other action such as DROP TRUNCATE ALTER INSERT DELETE


GRANT ALL ON Sales.* to 'frank'@'localhost';

	The above line will allow frank to do all the operations as we have used *


	Database administrators
		- people who have complete rights to a database
		- they can grant access to users and can revoke it

	the REVOKE clause
		- used to revoke the permission and privileges of database users
		- the exact opposite of GRANT

REVOKE type_of_permission ON database_name.table_name FROM 'username'@'localhost';

REVOKE SELECT ON sales.customers FROM 'frank'@'localhost';

---------------------------------------------------------------------
---------------------------------------------------------------------

Transaction Control language

	Transaction control Language (TCL)
		- Not every changes you make to a database is saved automatically

	the COMMIT statement
		- related to INSERT, DELETE, UPDATE
		- will save the changes you've made
		- will let other user have access to the modified version of the database

'''Imagine if we have changes some field using the update but to store the data to db we need'''

UPDATE customers
SET last_name = 'Johnson'
WHERE customer_id = 4
COMMIT;

	the COMMIT statement 
		- committed states can accrue
		- saves the transaction in the database
		- changes cannot be undone

	the ROLLBACK clause
	the clause that will let you make a step back
		- allows you to undo any changes you have made but 
			dont want to be saved permanently
		- allows you to take a step back
		- the last change(s) made will not count
		- reverts to the last non-committed state
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------


Relational database
	
	Organize huge amount of data that can be quickly retrieved - Well structured - efficient

THE SOLUTION IS TO HAVE RELATIONAL ALGEBRA

	the smallest units in the entire system that can carry integral logical meaning

	Relation Database Management System

	Three steps that are needed is the Database design, Database creation, Database Manipulation

	DATABASE DESIGN plot the entire database system on a canvas using a visualization tool

	Relational Schema :
		It is an table representation of data using the table name and column name
		where the Primary key are underlined and the foreign key are given tag (FK)

	
	DATABASE CREATION use SQL to set up the database physically

	DATABASE MANIPULATION allows you to use your dataset to extract business insights

DBMS = database design + creation + manipulation

-------------------------------------------------------------------------------------------

Relational Schemas : Primary Key 
	a column (or a set of columns) whise values exists and is unique
	for every record in a table is called a primary key
	
	Normally tables have a tabular form
	A relational Schema can be applied to represent them 

	EACH VALUE MUST BE UNIQUE AND SHOULD NOT BE NULL

	EACH TABLE CAN HAVE ONE AND ONLY ONE PRIMARY KEY
	IN A TABLE, YOU CANNOT HAVE 3 OR 4 PRIMARY KEY

Relating two table is done using the PRIMARY KEY and FOREIGN KEY option
	this is not a compulsion to have both same names can be of different names


Relational Schema : Foreign Key
	
	Always look for the foreign keys, as they show us where the relations are
	An foreign key is a primary of its own table and should not repeat or NULL
	
	While the column is used as a foreign key it can be NULL and repeated
	While the column is used as a foreign key it can contain number which are
	not in the PRIMARY KEY in its own table 
	
	Identifies the relationships between tables, not the tables themselves

Relational Schemas : Unique Key & Null Values

	Used whenever you would like to specific that you dont want to see 
	duplicate data in a given field (column)

			Primary Key	|	unique Key
			-----------------------------------
	NULL VALUES		no	|	yes	
	NO OF KEYS		1	|	0, 1, 2, ..
			------------------------------------
	Application
	to multi-column		YES	|	YES


--------------------------------------------------------------------------
--------------------------------------------------------------------------

RELATIONSHIPS
	
	relationships tell you how much of the data from a foreign key
	field can be seen in the primary key column of the table the data 
	is related to and vice versa

ONE to MANY type of relationship
ONE TO ONE type of relationship	
MANY to MANY type of relationship

-------------------------------------------------------------------------------------

STEP BY STEP CONCEPTS

1. Selecting all data 
	SELECT * FROM table_name;
	UPDATE table_name SET row-column = '1989-08-31' WHERE row-column = 'Bowser';
	
	SELECT * FROM pet;
	UPDATE pet SET birth = '1989-08-31' WHERE name = 'Bowser';

2. Selecting an particular row

	mysql> SELECT * FROM pet WHERE name = 'Bowser';
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+

	SELECT * FROM pet WHERE birth >= '1998-1-1';
	SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';
	SELECT * FROM pet WHERE species = 'snake' OR species = 'bird';
	SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm') OR (species = 'dog' AND sex = 'f');

3. Selecting an particular column

	mysql> SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+

	SELECT DISTINCT owner FROM pet;
	-- this is used to stop the duplication of row in our results

	SELECT name, species, birth FROM pet WHERE species = 'dog' OR species = 'cat';

4. Sorting Row

	mysql> SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+

	SELECT name, birth FROM pet ORDER BY birth DESC;

5. Date Calculations
	
	ADDDATE()	-- Add time values
	ADDTIME()	-- Add time
	CURDATE()	-- return the current date
	DATA()		-- Extract the date part of a date 
	SECOND()	-- Return the second (0-59)
	YEAR()		-- Return the year
	YEARWEEK()	-- return the year and week

	SELECT name, birth, CURDATE(),
       TIMESTAMPDIFF(YEAR,birth,CURDATE()) AS age
       FROM pet;
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
+----------+------------+------------+------+

	SELECT name, birth, MONTH(birth) FROM pet;
+----------+------------+--------------+
| name     | birth      | MONTH(birth) |
+----------+------------+--------------+
| Fluffy   | 1993-02-04 |            2 |
| Claws    | 1994-03-17 |            3 |
| Buffy    | 1989-05-13 |            5 |
| Fang     | 1990-08-27 |            8 |
| Bowser   | 1989-08-31 |            8 |
| Chirpy   | 1998-09-11 |            9 |
| Whistler | 1997-12-09 |           12 |
| Slim     | 1996-04-29 |            4 |
| Puffball | 1999-03-30 |            3 |
+----------+------------+--------------+

	SELECT name, birth FROM pet WHERE MONTH(birth) = 5;
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+


	SELECT TIMESTAMPDIFF(YEAR, start_date, end_date) AS years FROM 'schedular';
		-- the main difference is that we can calculate what ever we want say as date second hour

	SELECT 8 FROM 'schedular' WHERE DATEDIFF(end_date, start_date) 
		-- but while using the datediff we cannot calculate other and so the arrangement is also different
	

6. Working with NULL Values

	When doing an ORDER BY, NULL values are presented first if you do ORDER BY ... ASC 
	and last if you do ORDER BY ... DESC.
	To test for NULL, use the IS NULL and IS NOT NULL operators, as shown here:



SELECT 1 IS NULL, 1 IS NOT NULL;
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+

	
7. Pattern Matching:
	
	SELECT * FROM pet WHERE name LIKE 'b%';
		Which will match all the words starting with b

	SELECT * FROM pet WHERE name LIKE '%fy';
		which will match all the words ending with fy

	SELECT * FROM pet WHERE name LIKE '%w%';
		which will match all the words which has w in it

	SELECT * FROM pet WHERE name LIKE '_ _ _ _ _';
		which will match the exact number of time _ is given

	
	SELECT * FROM pet WHERE REGEXP_LIKE(name, '^b');
		which will match the words starting with b
		To make it case sensitive we can give
	SELECT * FROM pet WHERE REGEXP_LIKE(name, '^b' COLLATE utf8mb4_0900_as_cs);
	SELECT * FROM pet WHERE REGEXP_LIKE(name, BINARY '^b');
	SELECT * FROM pet WHERE REGEXP_LIKE(name, '^b', 'c');

	SELECT * FROM pet WHERE REGEXP_LIKE(name, 'fy$');
		which will match with the ending letter fy

	SELECT * FROM pet WHERE REGEXP_LIKE(name, 'w');
		which will match with words have contain w init

	SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.....$');
	SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.{5}$');
		which will match the the number of . and {n} n value char


8. Counting Rows
	
	SELECT COUNT(*) FROM pet;
+----------+
| COUNT(*) |
+----------+
|        9 |
+----------+
		which will return total rows in the database

	
	SELECT owner, COUNT(*) FROM pet GROUP BY owner;

	SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | NULL |        1 |
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+


WARNING:

mysql> SET sql_mode = 'ONLY_FULL_GROUP_BY';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT owner, COUNT(*) FROM pet;
ERROR 1140 (42000): In aggregated query without GROUP BY, expression
#1 of SELECT list contains nonaggregated column 'menagerie.pet.owner';
this is incompatible with sql_mode=only_full_group_by

-- Aggregate functions COUNT, SUM, AVG, MIN and MAX. SUM and AVG functions only work on numeric data. --

mysql> SET sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT owner, COUNT(*) FROM pet;
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Harold |        8 |
+--------+----------+
1 row in set (0.00 sec)

 
10. --



------------------------------------------------------------------------------------
------------------------------------------------------------------------------------

CREATE INDEX

	Creating index is a way to tell the mysql to create separate table again
	with the data present in the normal table 

	but whats different is when mysql builds an index table it does it in binary tree
	which makes it quicker to search the results using binary tree

we have four index which can be used to create 
		PRIMARY KEY
		UNIQUE KEY
		REGULAR 
		FULLTEXT

We have different method to create an index 

	1. while creating the table itself we can create the index
		CREATE TABLE products (
			product_id INT UNSIGNED NOT NULL AUTO_INCREMENT,
			product_name VARCHAR(100) NOT NULL,
			product_ sku CHAR(10) NOT NULL,
			product_desc VARCHAR(500) NOT NULL,
			PRIMARY KEY (product_id),
			INDEX idx_name (product_name),
			INDEX idx_duo (product_name, product_sku)
		);


	2. REGULAR - We can alter the table using the alter command 
		
		ALTER TABLE products
		ADD INDEX idx_sku (product_sku);

		-- DROP INDEX idx_sku ON products


	3. UNIQUE - We can alter the table using the alter command

		ALTER TABLE products
		ADD UNIQUE idx_sku (product_sku);


	4. FULLTEXT - we can create simply an index on the table
	
		CREATE FULLTEXT INDEX idx_text ON products (product_desc);

	5. Shorten index to create an short number of rows in indexs

		CREATE INDEX idx_sku_three ON products (product_sku(3));

--------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------

CREATE TRIGGER

	Creating a trigger is something like a middleware which gets triggered
	when we do something else say as INSERT UPDATE DELETE 
	
	You cannot associate a trigger with a TEMPORARY table or a view.

	To execute multiple statements, use the BEGIN ... END compound statement construct

	f you use LOCK TABLES to lock a table that has triggers, the tables used within the 
	trigger are also locked, as described in LOCK TABLES and Triggers.

	Within a trigger body, the CURRENT_USER function returns the account used to check 
	privileges at trigger activation time. This is the DEFINER user, not the user whose 
	actions caused the trigger to be activated.

	INSERT, LOAD DATA, REPLACE and UPDATE statements

	DELETE, REPLACE, DROP TABLE and TRUNCATE TABLE statements

	We can trigger things by defining them first the most simplest is to 
	CREATE TRIGGER

-----------------------------------------------------------
CREATE TRIGGER
    [DEFINER = user]
    TRIGGER trigger_name
    trigger_time trigger_event
    ON tbl_name FOR EACH ROW
    [trigger_order]
    trigger_body

trigger_time: { BEFORE | AFTER }

trigger_event: { INSERT | UPDATE | DELETE }

trigger_order: { FOLLOWS | PRECEDES } other_trigger_name

--------------------------------------------------------------

	CREATE TRIGGER tr_ins_character
	BEFORE INSERT ON characters
	FOR EACH ROW	-- This line is provided to perform action when bulk insert or ... is done
	SET NEW.character_name = UPPER(NEW.character_name);


	CREATE TRIGGER tr_up_char
	BEFORE UPDATE ON characters
	FOR EACH ROW
	SET NEW.character_name = LOWER(NEW.character_name);

Bonus is we can drop the old trigger if we have any using

	DROP TRIGGER IF EXISTS tr_ins_character;
	DROP TRIGGER IF EXISTS tr_up_char;

I/P
	INSERT INTO characters (character_name, race_id) VALUE ('Akhshy', 10);

O/P	AKHSHY

---------------------------------------------------------------------------------
------------------------------------------------------------------------------

CRAETE VIEWS

	Views is like an temporary table which becomes the output of the querie which we write
	View are like virtual table which is created for us by the SQL we write

	View will be always be the updated version from the database because it runs the queries all the time
	When we create a view with particular column name and after that 
	if we change the name of the column than our views WONT WORK
	we should drop the view and recreate the view with the new column name

	DROP VIEW scifi;
	
	A view cannot be written over a view

	view cannot have the these in then SQL we write
	-- UPDATEABLE VIEWS CANNOT INCLUDE
	-- Aggregate functions
	-- GROUP BY
	-- HAVING
	-- UNION
	-- DISTINCT
	-- LEFT RIGHT OUTER JOIN
	-- SubQueries

-------------------------------------------------
m
m_id m t ge

CREATE VIEW scifi AS 
SELECT m.movie_id, m.movie_title, g.genre_title
FROM movie AS m INNER JOIN genres AS g
WHERE genre_title = 'Sci-fi';

-- the above code is the join of two table with the primary and foreign key
	where the view is constructed with the name as Sci-fi 
	the table will contain the movie_id, movie_title and genre_title

-- this view table is virtual table which is created for us each time using the above SQL

NOTE : The main thing is if we update the value in views which will also change 
	the data in the database and vice versa.


------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------

data Manipulation Language (DML);
	
SUBQUERIES
	These are simply nested SQL which we write to get more specific data
	as a part of the filter query that is where line query
	The most simple way is to use the IN command to have subqueries

	SELECT *
	FROM 'movies'
	WHERE year IN (1996, 1994, 1986)

	-- Which we give us the results with year in these three
	-- This is so simple

	
	SELECT *
	FROM 'movies'
	WHERE genre_id IN ( 1, 2, 3)
	-- this much similar has the last one but what if we dont know the ID
	-- we can write the above SQL as 
	SELECT *
	FROM 'movies'
	WHERE genre_id IN (SELECT genre_id FROM genres)
	-- this is some thing which is called as the subqueries 
	-- we can nest the subqueries using the IN inside the ( )

	SELECT *
	FROM 'movies'
	WHERE genre_id IN (SELECT genre_id FROM genres WHERE genre_title = 'Fantasy') 
	-- this above SQL will take teh genre_id which as genre_tilte as fantasy

	SELECT * 
	FROM 'movies'
	WHERE genre_id IN (SELECT genre_id FROM genres WHERE genre_title IN ('Fantasy', 'horror', 'Sci-Fi'))
	-- This is nested subquerie as we have IN inside an IN

-----------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

SQL Statements

LOCK AND UNLOCK TABLE STATEMENT

	This is common practice where a live server usually does as the name tells you can say that
	we can lock the table by not allowing anything to happen inside the table and only after
	unlocking the table we can access data in the table

	As I said this is common because in application there may be multiple users trying to access 
	the same data at a time and that to in shopping sites we may get thousands of orders and we should
	keep a track of how many products that have been sold and how much is remaining and you can figure
	out what I am going towards 
	Yeah when an user clicks buy the database should update if its one user no prob but when its so many
	our database cannot handly multiple request from the multiple user and so we need to lock the databases
	and unlock once the data convertion or updation is done by single user

LOCK TABLES
    tbl_name [[AS] alias] lock_type
    [, tbl_name [[AS] alias] lock_type] ...

lock_type: {
    READ [LOCAL]
  | [LOW_PRIORITY] WRITE
}

UNLOCK TABLES


CREATE DATABASE locking

USE locking

CREATE TABLE products (p1 VARCHAR(5) NOT NULL PRIMARY KEY, v2 VARCHAR(5) NOT NULL)

CREATE user 'user_b'@'localhost'

GRANT ALL ON locking. to 'user_b'@'localhost'

-- READ --
LOCK TABLE products READ

-- WRITE --
LOCK TABLE products WRITE

-- UNLOCK --
UNLOCK TABLE

-------------------------------------------------------------------
while in user_b we can 

USE locking

-- This cannot be done when write lock is kept on table product --
INSERT INTO products VALUES ('PEN','PENCIL')

-- This cannot be done when read lock is kept on table product --
SELECT * FROM products   

----------------------------------------------------------------------

A session that requires locks must acquire all the locks that it needs in a 
single LOCK TABLES statement. While the locks thus obtained are held, the 
session can access only the locked tables. 

WRITE locks normally have higher priority than READ locks to ensure 
that updates are processed as soon as possible. This means that if one 
session obtains a READ lock and then another session requests a WRITE lock, 
subsequent READ lock requests wait until the session that requested the WRITE 
lock has obtained the lock and released it. (An exception to this policy can 
occur for small values of the max_write_lock_count system variable;
